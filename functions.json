[
  {
    "routine_name": "approve_vendor_application",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  is_caller_admin boolean;\nBEGIN\n  -- 1. Verify the caller is an admin (using the SECURITY INVOKER version is fine here)\n  SELECT public.is_admin() INTO is_caller_admin;\n  IF NOT is_caller_admin THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not an admin.';\n  END IF;\n\n  -- 2. Update vendor_applications table\n  UPDATE public.vendor_applications\n  SET\n    status = 'approved',\n    reviewer_notes = p_reviewer_notes,\n    reviewed_at = now()\n  WHERE id = p_application_id;\n\n  -- Check if application was found and updated (optional but good practice)\n  IF NOT FOUND THEN\n      RAISE WARNING 'Vendor application with ID % not found.', p_application_id;\n      -- Decide if this should be an error or just a warning\n      -- RETURN; -- Or raise exception if application must exist\n  END IF;\n\n  -- 3. Update profiles table\n  UPDATE public.profiles\n  SET\n    role = 'vendor',\n    status = 'active'\n  WHERE id = p_user_id;\n\n  -- Check if profile was found and updated (optional)\n  IF NOT FOUND THEN\n      RAISE WARNING 'Profile with user ID % not found.', p_user_id;\n      -- This indicates a data inconsistency issue if the application existed but the profile didn't\n  END IF;\n\n  -- Optionally return success status or message\n  -- RETURN;\n\nEND;\n"
  },
  {
    "routine_name": "check_vendor_order_access",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "SQL",
    "routine_definition": "\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = p_order_id\n      AND c.vendor_id = auth.uid() -- Check if the counter belongs to the current user\n  );\n"
  },
  {
    "routine_name": "create_pos_order",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n    v_order_id uuid;\n    v_total_price numeric := 0;\n    v_input_item public.pos_order_item_input;\n    v_menu_item record;\n    v_price_at_order numeric;\n    v_item_id_to_insert uuid;\n    v_quantity_to_insert integer;\n    v_spec_instructions_to_insert text;\n    v_student_balance numeric;\n    v_user_id_for_insert uuid; -- Renamed variable for clarity\nBEGIN\n    -- Input validation\n    IF p_vendor_user_id IS NULL THEN RAISE EXCEPTION 'Vendor user ID cannot be null'; END IF;\n    IF p_counter_id IS NULL THEN RAISE EXCEPTION 'Counter ID cannot be null'; END IF;\n    IF p_payment_method IS NULL THEN RAISE EXCEPTION 'Payment method cannot be null'; END IF;\n    IF array_length(p_items, 1) IS NULL OR array_length(p_items, 1) = 0 THEN RAISE EXCEPTION 'Order must contain at least one item'; END IF;\n    IF p_payment_method = 'online' AND p_student_user_id IS NULL THEN RAISE EXCEPTION 'Student user ID is required for online payments.'; END IF;\n\n    -- 1. Pre-check loop: Validate items and calculate total price\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        IF v_input_item.quantity <= 0 THEN RAISE EXCEPTION 'Item quantity must be positive for menu item %', v_input_item.menu_item_id; END IF;\n        SELECT id, price, stock, available, counter_id INTO v_menu_item FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        IF NOT FOUND THEN RAISE EXCEPTION 'Menu item % not found', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.counter_id != p_counter_id THEN RAISE EXCEPTION 'Menu item % does not belong to counter %', v_input_item.menu_item_id, p_counter_id; END IF;\n        IF NOT v_menu_item.available THEN RAISE EXCEPTION 'Menu item % is not available', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.stock IS NOT NULL AND v_menu_item.stock < v_input_item.quantity THEN\n            RAISE EXCEPTION 'Insufficient stock for menu item % (available: %, requested: %)', v_input_item.menu_item_id, v_menu_item.stock, v_input_item.quantity;\n        END IF;\n        v_total_price := v_total_price + (v_menu_item.price * v_input_item.quantity);\n    END LOOP;\n\n    -- 2. Check student balance AND DEDUCT if payment is online\n    IF p_payment_method = 'online' THEN\n        SELECT balance INTO v_student_balance FROM public.profiles WHERE id = p_student_user_id FOR UPDATE;\n        IF NOT FOUND THEN RAISE EXCEPTION 'Student profile not found for ID %', p_student_user_id; END IF;\n        IF v_student_balance IS NULL OR v_student_balance < v_total_price THEN\n            RAISE EXCEPTION 'Insufficient student balance (Available: %, Required: %)', COALESCE(v_student_balance, 0), v_total_price;\n        END IF;\n        UPDATE public.profiles SET balance = balance - v_total_price WHERE id = p_student_user_id;\n        -- Explicitly set the user ID for insert AFTER balance check\n        v_user_id_for_insert := p_student_user_id;\n    ELSE\n        -- Explicitly set the user ID for insert for cash orders\n        v_user_id_for_insert := p_vendor_user_id;\n    END IF;\n\n    -- 3. Insert the main order record\n    INSERT INTO public.orders (user_id, total_price, status, pickup_time, subtotal, tax, payment_method)\n    VALUES (\n        v_user_id_for_insert, -- Use the explicitly assigned variable\n        v_total_price,\n        'completed'::public.order_status,\n        now(),\n        v_total_price,\n        0,\n        p_payment_method\n    )\n    RETURNING id INTO v_order_id;\n\n    -- 4. Main loop: Insert order items and update stock\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        SELECT price INTO v_price_at_order FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        v_item_id_to_insert := v_input_item.menu_item_id;\n        v_quantity_to_insert := v_input_item.quantity;\n        v_spec_instructions_to_insert := v_input_item.special_instructions;\n        INSERT INTO public.order_items (order_id, menu_item_id, quantity, price_at_order, counter_id, special_instructions, status)\n        VALUES (v_order_id, v_item_id_to_insert, v_quantity_to_insert, v_price_at_order, p_counter_id, v_spec_instructions_to_insert, 'delivered'::public.order_item_status);\n        UPDATE public.menu_items SET stock = stock - v_quantity_to_insert WHERE id = v_item_id_to_insert AND stock IS NOT NULL;\n    END LOOP;\n\n    -- 5. Update Vendor Balance (Added Step)\n    UPDATE public.profiles\n    SET balance = COALESCE(balance, 0) + v_total_price\n    WHERE id = p_vendor_user_id;\n\n    -- 6. Return the new order ID\n    RETURN v_order_id;\n\nEXCEPTION WHEN OTHERS THEN\n    RAISE WARNING 'Error in create_pos_order: %', SQLERRM;\n    RAISE; -- Re-raise to ensure transaction rollback\nEND;\n"
  },
  {
    "routine_name": "create_pos_order",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n    v_order_id uuid;\n    v_total_price numeric := 0;\n    v_input_item public.pos_order_item_input;\n    v_menu_item record;\n    v_price_at_order numeric;\n    v_item_id_to_insert uuid;\n    v_quantity_to_insert integer;\n    v_spec_instructions_to_insert text;\nBEGIN\n    -- Input validation\n    IF p_vendor_user_id IS NULL THEN RAISE EXCEPTION 'Vendor user ID cannot be null'; END IF;\n    IF p_counter_id IS NULL THEN RAISE EXCEPTION 'Counter ID cannot be null'; END IF;\n    IF array_length(p_items, 1) IS NULL OR array_length(p_items, 1) = 0 THEN RAISE EXCEPTION 'Order must contain at least one item'; END IF;\n\n    -- 1. Pre-check loop: Validate items and calculate total price\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        IF v_input_item.quantity <= 0 THEN RAISE EXCEPTION 'Item quantity must be positive for menu item %', v_input_item.menu_item_id; END IF;\n        SELECT id, price, stock, available, counter_id INTO v_menu_item FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        IF NOT FOUND THEN RAISE EXCEPTION 'Menu item % not found', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.counter_id != p_counter_id THEN RAISE EXCEPTION 'Menu item % does not belong to counter %', v_input_item.menu_item_id, p_counter_id; END IF;\n        IF NOT v_menu_item.available THEN RAISE EXCEPTION 'Menu item % is not available', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.stock IS NOT NULL AND v_menu_item.stock < v_input_item.quantity THEN\n            RAISE EXCEPTION 'Insufficient stock for menu item % (available: %, requested: %)', v_input_item.menu_item_id, v_menu_item.stock, v_input_item.quantity;\n        END IF;\n        v_total_price := v_total_price + (v_menu_item.price * v_input_item.quantity);\n    END LOOP;\n\n    -- 2. Insert the main order record (Cash only logic)\n    INSERT INTO public.orders (user_id, total_price, status, pickup_time, subtotal, tax, payment_method)\n    VALUES (p_vendor_user_id, v_total_price, 'completed'::public.order_status, now(), v_total_price, 0, 'cash'::public.payment_method_type)\n    RETURNING id INTO v_order_id;\n\n    -- 3. Main loop: Insert order items and update stock\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        SELECT price INTO v_price_at_order FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        v_item_id_to_insert := v_input_item.menu_item_id;\n        v_quantity_to_insert := v_input_item.quantity;\n        v_spec_instructions_to_insert := v_input_item.special_instructions;\n        INSERT INTO public.order_items (order_id, menu_item_id, quantity, price_at_order, counter_id, special_instructions, status)\n        VALUES (v_order_id, v_item_id_to_insert, v_quantity_to_insert, v_price_at_order, p_counter_id, v_spec_instructions_to_insert, 'delivered'::public.order_item_status);\n        UPDATE public.menu_items SET stock = stock - v_quantity_to_insert WHERE id = v_item_id_to_insert AND stock IS NOT NULL;\n    END LOOP;\n\n    -- 4. Return the new order ID\n    RETURN v_order_id;\n\nEXCEPTION WHEN OTHERS THEN\n    RAISE WARNING 'Error in create_pos_order: %', SQLERRM;\n    RAISE;\nEND;\n"
  },
  {
    "routine_name": "decrement_menu_item_stock",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n    -- Check for positive quantity\n    IF p_quantity <= 0 THEN\n        RAISE WARNING 'Decrement quantity must be positive for menu item %.', p_menu_item_id;\n        RETURN; -- Do nothing if quantity is not positive\n    END IF;\n\n    -- Update stock only if stock tracking is enabled (stock is not null)\n    UPDATE public.menu_items\n    SET stock = stock - p_quantity\n    WHERE id = p_menu_item_id\n      AND stock IS NOT NULL; -- Only decrement if stock is tracked\n\n    -- Optional: Add a check after update to see if stock went negative,\n    -- although pre-checks in application logic should ideally prevent this.\n    -- Example:\n    -- IF FOUND AND (SELECT stock FROM public.menu_items WHERE id = p_menu_item_id) < 0 THEN\n    --     RAISE WARNING 'Stock for menu item % went negative after decrement.', p_menu_item_id;\n    --     -- Consider corrective action or more robust error handling if needed\n    -- END IF;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Log any unexpected errors during the stock update\n        RAISE WARNING 'Error in decrement_menu_item_stock for item %: %', p_menu_item_id, SQLERRM;\n        -- Re-raise the exception if you want the calling transaction to fail\n        -- RAISE;\nEND;\n"
  },
  {
    "routine_name": "get_user_id_by_student_id",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n    v_user_id uuid;\nBEGIN\n    -- SECURITY DEFINER should allow reading profiles table if owner has permission.\n    SELECT id\n    INTO v_user_id\n    FROM public.profiles\n    WHERE student_id = p_student_id -- Query using the TEXT column 'student_id' based on error/tables.json\n      AND role = 'student'::public.user_role; -- Ensure the profile is actually a student\n\n    -- Explicitly return NULL if no user was found\n    IF NOT FOUND THEN\n        RETURN NULL;\n    END IF;\n\n    RETURN v_user_id; -- Returns the found UUID\nEND;\n"
  },
  {
    "routine_name": "get_user_role",
    "routine_type": "FUNCTION",
    "data_type": "USER-DEFINED",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  user_role public.user_role;\nBEGIN\n  -- Ensure the user has SELECT permission on the relevant columns of their own profile row\n  -- The existing RLS policy \"Users can view their own profile.\" should cover this.\n  SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid();\n  RETURN user_role;\nEND;\n"
  },
  {
    "routine_name": "get_vendor_orders_with_student_details",
    "routine_type": "FUNCTION",
    "data_type": "record",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  -- Check if the caller is a vendor\n  IF NOT public.is_vendor() THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not a vendor.';\n  END IF;\n\n  RETURN QUERY\n  SELECT\n    o.id,\n    o.user_id,\n    o.total_price,\n    o.subtotal,\n    o.tax,\n    o.status,\n    o.pickup_time,\n    o.created_at,\n    o.payment_method,\n    -- Select profile details only if it's an 'online' order, otherwise null\n    CASE\n      WHEN o.payment_method = 'online' THEN p.full_name\n      ELSE NULL\n    END AS student_full_name,\n    CASE\n      WHEN o.payment_method = 'online' THEN p.student_id -- This is the registration ID column\n      ELSE NULL\n    END AS student_reg_id\n  FROM\n    public.orders o\n  -- Left join profiles for online orders\n  LEFT JOIN public.profiles p ON o.user_id = p.id AND o.payment_method = 'online'\n  -- Ensure the vendor has at least one item from their counters in this order\n  WHERE EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = o.id\n      AND c.vendor_id = auth.uid()\n  )\n  ORDER BY\n    o.created_at DESC;\n\nEND;\n"
  },
  {
    "routine_name": "handle_new_user",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  user_role public.user_role := 'student'; -- Default role\n  profile_stat public.profile_status := 'active'; -- Default status for non-vendors\nBEGIN\n  -- Check if metadata indicates a vendor application signup\n  IF NEW.raw_user_meta_data ->> 'is_vendor_application' = 'true' THEN -- Corrected metadata field\n    user_role := 'vendor';\n    profile_stat := 'pending_approval'; -- Set status for vendors needing approval\n  END IF;\n\n  INSERT INTO public.profiles (id, email, full_name, student_id, phone_number, role, status)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    -- Extract metadata passed in options.data during signup\n    NEW.raw_user_meta_data ->> 'full_name',\n    NEW.raw_user_meta_data ->> 'student_id',\n    NEW.raw_user_meta_data ->> 'phone', -- Assumes 'phone' is passed in options.data\n    user_role,  -- Use the determined role\n    profile_stat -- Use the determined status\n  );\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "handle_user_email_update",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  UPDATE public.profiles\n  SET email = NEW.email\n  WHERE id = NEW.id;\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "is_admin",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  -- Relies on get_user_role() which is now SECURITY INVOKER\n  RETURN public.get_user_role() = 'admin'::public.user_role;\nEND;\n"
  },
  {
    "routine_name": "is_student",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  RETURN public.get_user_role() = 'student'::public.user_role;\nEND;\n"
  },
  {
    "routine_name": "is_vendor",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  RETURN public.get_user_role() = 'vendor'::public.user_role;\nEND;\n"
  },
  {
    "routine_name": "mark_item_delivered_and_update_order",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  v_order_id uuid;\n  v_counter_id uuid;\n  v_vendor_id uuid := auth.uid(); -- Get the current user's ID\n  v_user_role public.user_role;\n  v_all_items_delivered boolean;\n  v_current_order_status public.order_status;\nBEGIN\n  -- Check if the current user has the 'vendor' role\n  SELECT role INTO v_user_role\n  FROM public.profiles\n  WHERE id = v_vendor_id;\n\n  IF v_user_role IS NULL OR v_user_role <> 'vendor'::public.user_role THEN\n    RAISE EXCEPTION 'Permission denied: User is not a vendor.'; -- Modified error message\n  END IF;\n\n  -- Get order_id and counter_id, and verify vendor ownership of the counter\n  -- The vendor ID check (c.vendor_id = v_vendor_id) now uses the confirmed vendor's auth.uid()\n  SELECT oi.order_id, oi.counter_id INTO v_order_id, v_counter_id\n  FROM public.order_items oi\n  JOIN public.counters c ON oi.counter_id = c.id\n  WHERE oi.id = p_order_item_id AND c.vendor_id = v_vendor_id;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Permission denied: Order item not found or does not belong to this vendor.';\n  END IF;\n\n  -- Update the specific order item status to 'delivered'\n  UPDATE public.order_items\n  SET status = 'delivered'\n  WHERE id = p_order_item_id;\n\n  -- Check the current status of the main order\n  SELECT status INTO v_current_order_status FROM public.orders WHERE id = v_order_id;\n\n  -- Only proceed if the order is not already completed or cancelled\n  IF v_current_order_status <> 'completed' AND v_current_order_status <> 'cancelled' THEN\n\n    -- Check if all items for this order are now delivered\n    SELECT NOT EXISTS (\n      SELECT 1\n      FROM public.order_items\n      WHERE order_id = v_order_id AND status <> 'delivered'\n    ) INTO v_all_items_delivered;\n\n    -- Update the main order status\n    IF v_all_items_delivered THEN\n      UPDATE public.orders\n      SET status = 'completed'\n      WHERE id = v_order_id;\n    ELSE\n      -- If at least one item is delivered (which we just did), set to partially_completed\n      UPDATE public.orders\n      SET status = 'partially_completed'\n      WHERE id = v_order_id;\n    END IF;\n\n  END IF;\n\nEND;\n"
  },
  {
    "routine_name": "reject_vendor_application",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  is_caller_admin boolean;\nBEGIN\n  -- 1. Verify the caller is an admin\n  SELECT public.is_admin() INTO is_caller_admin;\n  IF NOT is_caller_admin THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not an admin.';\n  END IF;\n\n  -- 2. Update vendor_applications table\n  UPDATE public.vendor_applications\n  SET\n    status = 'rejected',\n    reviewer_notes = p_reviewer_notes,\n    reviewed_at = now()\n  WHERE id = p_application_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Vendor application with ID % not found.', p_application_id;\n  END IF;\n\n  -- 3. Update profiles table status to 'rejected'\n  UPDATE public.profiles\n  SET\n    status = 'rejected' -- Set profile status to rejected\n  WHERE id = p_user_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Profile with user ID % not found.', p_user_id;\n  END IF;\n\nEND;\n"
  },
  {
    "routine_name": "trigger_set_timestamp",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_menu_item_availability_on_stock_change",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "PLPGSQL",
    "routine_definition": "\nBEGIN\n  -- Check if stock is being updated and is not null\n  IF NEW.stock IS NOT NULL THEN\n    -- If stock is zero or less, set available to false\n    IF NEW.stock <= 0 THEN\n      NEW.available := false;\n    -- Optional: If stock is positive, set available to true\n    -- Consider if manual override of 'available = false' is needed.\n    -- For now, we'll re-enable if stock increases above 0.\n    ELSIF NEW.stock > 0 THEN\n       NEW.available := true;\n    END IF;\n  END IF;\n\n  -- Return the modified row\n  RETURN NEW;\nEND;\n"
  },
  {
    "routine_name": "update_order_status_based_on_items",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  item_statuses order_item_status[]; -- Use the correct enum type if defined, otherwise text[]\n  total_items integer;\n  pending_count integer;\n  preparing_count integer; -- Added count for preparing\n  ready_count integer;\n  delivered_count integer;\n  new_order_status order_status; -- Use the correct enum type\n  current_order_status order_status; -- To check current status for pending->confirmed logic\nBEGIN\n  -- 1. Get all item statuses for the given order\n  SELECT array_agg(status), count(*)\n  INTO item_statuses, total_items\n  FROM public.order_items\n  WHERE order_id = p_order_id;\n\n  -- Handle case where order has no items (shouldn't happen in normal flow)\n  IF total_items IS NULL OR total_items = 0 THEN\n    RAISE WARNING 'Order % has no items, cannot determine status.', p_order_id;\n    -- Optionally set status to 'cancelled' or leave as is\n    -- UPDATE public.orders SET status = 'cancelled' WHERE id = p_order_id;\n    RETURN;\n  END IF;\n\n  -- 2. Count items in each status category, including 'preparing'\n  SELECT\n    count(*) FILTER (WHERE status = 'pending'),\n    count(*) FILTER (WHERE status = 'preparing'), -- Count preparing items\n    count(*) FILTER (WHERE status = 'ready'),\n    count(*) FILTER (WHERE status = 'delivered')\n  INTO pending_count, preparing_count, ready_count, delivered_count\n  FROM public.order_items\n  WHERE order_id = p_order_id;\n\n  -- 3. Determine the new overall order status based on item counts (Revised Logic)\n  IF delivered_count = total_items THEN\n    new_order_status := 'completed';\n  ELSIF delivered_count > 0 THEN\n    new_order_status := 'partially_delivered'; -- If any are delivered, it's partially delivered (highest precedence after completed)\n  ELSIF ready_count = total_items THEN\n     new_order_status := 'ready'; -- If all remaining are ready\n  ELSIF preparing_count > 0 THEN\n     new_order_status := 'preparing'; -- If any are preparing (and none delivered), the order is preparing\n  ELSIF ready_count > 0 THEN\n    new_order_status := 'partially_ready'; -- If some are ready, others pending (none preparing or delivered)\n  ELSIF pending_count = total_items THEN\n     -- If all items are pending, check the current order status.\n     -- If it was 'confirmed', keep it as 'confirmed'. Otherwise, set to 'pending'.\n     -- This prevents reverting from 'confirmed' back to 'pending' just because items haven't started preparation.\n     SELECT status INTO current_order_status FROM public.orders WHERE id = p_order_id;\n     IF current_order_status = 'confirmed' THEN\n        new_order_status := 'confirmed';\n     ELSE\n        new_order_status := 'pending'; -- Default for new orders or if somehow reverted\n     END IF;\n  ELSE\n     -- Fallback case: Should ideally not be reached with the logic above.\n     -- If it is reached, it implies a mix not covered (e.g., only pending and preparing?). Default to preparing if any exist.\n     IF preparing_count > 0 THEN\n         new_order_status := 'preparing';\n     ELSIF ready_count > 0 THEN\n         new_order_status := 'partially_ready';\n     ELSE\n         new_order_status := 'pending';\n     END IF;\n     RAISE WARNING 'Order % hit fallback status logic. Counts: Pending=%, Preparing=%, Ready=%, Delivered=%, Total=%. Setting status to %',\n         p_order_id, pending_count, preparing_count, ready_count, delivered_count, total_items, new_order_status;\n  END IF;\n\n  -- 4. Update the order status only if it has changed\n  UPDATE public.orders\n  SET status = new_order_status, updated_at = now()\n  WHERE id = p_order_id AND status IS DISTINCT FROM new_order_status;\n\nEND;\n"
  },
  {
    "routine_name": "update_order_status_direct",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "PLPGSQL",
    "routine_definition": "\nDECLARE\n  is_caller_vendor_associated boolean;\nBEGIN\n  -- Security Check: Verify the caller is actually a vendor associated with this order.\n  -- This prevents a vendor from updating orders they don't handle.\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = p_order_id\n      AND c.vendor_id = auth.uid() -- Check if any item's counter belongs to the calling vendor\n  ) INTO is_caller_vendor_associated;\n\n  IF NOT is_caller_vendor_associated THEN\n    -- Additionally check if the order was a POS cash order placed by the vendor themselves\n    IF NOT EXISTS (\n        SELECT 1 FROM public.orders o\n        WHERE o.id = p_order_id\n        AND o.payment_method = 'cash'\n        AND o.user_id = auth.uid() -- Vendor placed the order\n    ) THEN\n        RAISE EXCEPTION 'Permission denied: Caller (%) is not an associated vendor for order %', auth.uid(), p_order_id;\n    END IF;\n  END IF;\n\n  -- Proceed with the update if the security check passes\n  UPDATE public.orders\n  SET status = p_new_status, updated_at = now()\n  WHERE id = p_order_id;\n\n  -- Optional: Check if the update was successful (order existed)\n  IF NOT FOUND THEN\n    RAISE WARNING 'Order % not found for direct status update to %.', p_order_id, p_new_status;\n    RETURN; -- Exit if order wasn't found\n  END IF;\n\n  -- Decrement stock if the new status is 'completed'\n  IF p_new_status = 'completed' THEN\n    DECLARE\n      item_record record;\n    BEGIN\n      -- Loop through order items and decrement stock using the dedicated function\n      FOR item_record IN\n        SELECT menu_item_id, quantity\n        FROM public.order_items\n        WHERE order_id = p_order_id\n      LOOP\n        -- Call the stock decrement function for each item\n        PERFORM public.decrement_menu_item_stock(item_record.menu_item_id, item_record.quantity);\n      END LOOP;\n    EXCEPTION\n      WHEN OTHERS THEN\n        -- Log error during stock decrement but don't fail the status update itself\n        RAISE WARNING 'Error decrementing stock for order % during completion: %', p_order_id, SQLERRM;\n    END;\n  END IF;\n\nEND;\n"
  }
]