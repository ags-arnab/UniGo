[
  {
    "routine_name": "get_user_id_by_student_id",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.get_user_id_by_student_id(p_student_id text)\n RETURNS uuid\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id uuid;\nBEGIN\n    -- SECURITY DEFINER should allow reading profiles table if owner has permission.\n    SELECT id\n    INTO v_user_id\n    FROM public.profiles\n    WHERE student_id = p_student_id -- Query using the TEXT column 'student_id' based on error/tables.json\n      AND role = 'student'::public.user_role; -- Ensure the profile is actually a student\n\n    -- Explicitly return NULL if no user was found\n    IF NOT FOUND THEN\n        RETURN NULL;\n    END IF;\n\n    RETURN v_user_id; -- Returns the found UUID\nEND;\n$function$\n"
  },
  {
    "routine_name": "increment_menu_item_stock",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.increment_menu_item_stock(p_menu_item_id uuid, p_quantity integer)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check for positive quantity\n    IF p_quantity <= 0 THEN\n        RAISE WARNING 'Increment quantity must be positive for menu item %.', p_menu_item_id;\n        RETURN; -- Do nothing if quantity is not positive\n    END IF;\n\n    -- Update stock only if stock tracking is enabled (stock is not null)\n    UPDATE public.menu_items\n    SET stock = stock + p_quantity\n    WHERE id = p_menu_item_id\n      AND stock IS NOT NULL; -- Only increment if stock is tracked\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Log any unexpected errors during the stock update\n        RAISE WARNING 'Error in increment_menu_item_stock for item %: %', p_menu_item_id, SQLERRM;\n        -- Re-raise the exception if you want the calling transaction to fail\n        -- RAISE;\nEND;\n$function$\n"
  },
  {
    "routine_name": "cancel_expired_event_reservations",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.cancel_expired_event_reservations()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cancelled_count integer := 0;\nBEGIN\n  WITH expired AS (\n    UPDATE public.event_registrations\n    SET status = 'cancelled'\n    WHERE\n      status = 'reserved'\n      AND expires_at IS NOT NULL\n      AND expires_at < now()\n    RETURNING id -- Return IDs of cancelled registrations\n  )\n  SELECT count(*) INTO cancelled_count FROM expired;\n\n  IF cancelled_count > 0 THEN\n    RAISE LOG 'Cancelled % expired event reservations.', cancelled_count;\n  END IF;\n\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE WARNING 'Error in cancel_expired_event_reservations: %', SQLERRM;\nEND;\n$function$\n"
  },
  {
    "routine_name": "is_club",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.is_club()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check if the user exists in profiles and has the 'club' role\n  RETURN EXISTS (\n      SELECT 1\n      FROM public.profiles\n      WHERE id = auth.uid() AND role = 'club'::public.user_role\n  );\nEND;\n$function$\n"
  },
  {
    "routine_name": "handle_new_user",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  user_role public.user_role := 'student'; -- Default role\n  profile_stat public.profile_status := 'active'; -- Default status\n  is_applying_for_vendor boolean := false;\n  is_applying_for_club boolean := false;\nBEGIN\n  -- Check metadata for application type safely\n  is_applying_for_vendor := (NEW.raw_user_meta_data ->> 'is_vendor_application')::boolean;\n  is_applying_for_club := (NEW.raw_user_meta_data ->> 'is_club_application')::boolean;\n\n  -- Determine role and status based on application flags\n  -- Ensure 'club' value exists before assigning it\n  IF is_applying_for_club AND EXISTS (SELECT 1 FROM pg_enum WHERE enumtypid = 'user_role'::regtype AND enumlabel = 'club') THEN\n    user_role := 'club';\n    profile_stat := 'pending_approval';\n  ELSIF is_applying_for_vendor THEN -- Check vendor *after* club\n    user_role := 'vendor';\n    profile_stat := 'pending_approval';\n  END IF;\n\n  -- Insert into profiles table\n  INSERT INTO public.profiles (id, email, full_name, student_id, phone_number, role, status)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    NEW.raw_user_meta_data ->> 'full_name',\n    NEW.raw_user_meta_data ->> 'student_id',\n    NEW.raw_user_meta_data ->> 'phone',\n    user_role,\n    profile_stat\n  );\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "routine_name": "update_order_status_direct",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.update_order_status_direct(p_order_id uuid, p_new_status order_status)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  is_caller_vendor_associated boolean;\nBEGIN\n  -- Security Check: Verify the caller is actually a vendor associated with this order.\n  -- This prevents a vendor from updating orders they don't handle.\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = p_order_id\n      AND c.vendor_id = auth.uid() -- Check if any item's counter belongs to the calling vendor\n  ) INTO is_caller_vendor_associated;\n\n  IF NOT is_caller_vendor_associated THEN\n    -- Additionally check if the order was a POS cash order placed by the vendor themselves\n    IF NOT EXISTS (\n        SELECT 1 FROM public.orders o\n        WHERE o.id = p_order_id\n        AND o.payment_method = 'cash'\n        AND o.user_id = auth.uid() -- Vendor placed the order\n    ) THEN\n        RAISE EXCEPTION 'Permission denied: Caller (%) is not an associated vendor for order %', auth.uid(), p_order_id;\n    END IF;\n  END IF;\n\n  -- Proceed with the update if the security check passes\n  UPDATE public.orders\n  SET status = p_new_status, updated_at = now()\n  WHERE id = p_order_id;\n\n  -- Optional: Check if the update was successful (order existed)\n  IF NOT FOUND THEN\n    RAISE WARNING 'Order % not found for direct status update to %.', p_order_id, p_new_status;\n    RETURN; -- Exit if order wasn't found\n  END IF;\n\n  -- Stock is now decremented at order creation time.\n\n  -- Increment stock if the new status is 'cancelled'\n  IF p_new_status = 'cancelled' THEN\n    DECLARE\n      item_record record;\n    BEGIN\n      -- Loop through ALL order items and increment stock\n      FOR item_record IN\n        SELECT oi.menu_item_id, oi.quantity\n        FROM public.order_items oi\n        WHERE oi.order_id = p_order_id\n        -- No need to check item status, increment for all items in the cancelled order\n      LOOP\n        -- Call the stock increment function for each item\n        PERFORM public.increment_menu_item_stock(item_record.menu_item_id, item_record.quantity);\n      END LOOP;\n    EXCEPTION\n      WHEN OTHERS THEN\n        -- Log error during stock increment but don't fail the status update itself\n        RAISE WARNING 'Error incrementing stock for cancelled order %: %', p_order_id, SQLERRM;\n    END;\n  END IF;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "get_vendor_orders_with_student_details",
    "routine_type": "FUNCTION",
    "data_type": "TABLE(id uuid, user_id uuid, total_price numeric, subtotal numeric, tax numeric, status order_status, pickup_time timestamp with time zone, created_at timestamp with time zone, payment_method text, student_full_name text, student_reg_id text)",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.get_vendor_orders_with_student_details()\n RETURNS TABLE(id uuid, user_id uuid, total_price numeric, subtotal numeric, tax numeric, status order_status, pickup_time timestamp with time zone, created_at timestamp with time zone, payment_method text, student_full_name text, student_reg_id text)\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Check if the caller is a vendor\n  IF NOT public.is_vendor() THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not a vendor.';\n  END IF;\n\n  RETURN QUERY\n  SELECT\n    o.id,\n    o.user_id,\n    o.total_price,\n    o.subtotal,\n    o.tax,\n    o.status,\n    o.pickup_time,\n    o.created_at,\n    o.payment_method,\n    -- Select profile details only if it's an 'online' order, otherwise null\n    CASE\n      WHEN o.payment_method = 'online' THEN p.full_name\n      ELSE NULL\n    END AS student_full_name,\n    CASE\n      WHEN o.payment_method = 'online' THEN p.student_id -- This is the registration ID column\n      ELSE NULL\n    END AS student_reg_id\n  FROM\n    public.orders o\n  -- Left join profiles for online orders\n  LEFT JOIN public.profiles p ON o.user_id = p.id AND o.payment_method = 'online'\n  -- Ensure the vendor has at least one item from their counters in this order\n  WHERE EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = o.id\n      AND c.vendor_id = auth.uid()\n  )\n  ORDER BY\n    o.created_at DESC;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "get_user_role",
    "routine_type": "FUNCTION",
    "data_type": "user_role",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.get_user_role()\n RETURNS user_role\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  user_role public.user_role;\nBEGIN\n  SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid();\n  RETURN user_role;\nEND;\n$function$\n"
  },
  {
    "routine_name": "is_admin",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN public.get_user_role() = 'admin'::public.user_role;\nEND;\n$function$\n"
  },
  {
    "routine_name": "is_vendor",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.is_vendor()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN public.get_user_role() = 'vendor'::public.user_role;\nEND;\n$function$\n"
  },
  {
    "routine_name": "is_student",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.is_student()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN public.get_user_role() = 'student'::public.user_role;\nEND;\n$function$\n"
  },
  {
    "routine_name": "check_vendor_order_access",
    "routine_type": "FUNCTION",
    "data_type": "boolean",
    "external_language": "sql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.check_vendor_order_access(p_order_id uuid)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\n  SELECT EXISTS (\n    SELECT 1\n    FROM public.order_items oi\n    JOIN public.counters c ON oi.counter_id = c.id\n    WHERE oi.order_id = p_order_id\n      AND c.vendor_id = auth.uid()\n  );\n$function$\n"
  },
  {
    "routine_name": "create_student_order",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.create_student_order(p_student_user_id uuid, p_items pos_order_item_input[], p_pickup_time timestamp with time zone, p_subtotal numeric, p_tax numeric, p_total_price numeric)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_order_id uuid;\n    v_input_item public.pos_order_item_input;\n    v_menu_item record; -- Used to fetch item details like price, stock, counter_id\n    v_price_at_order numeric;\n    v_item_id_to_insert uuid;\n    v_quantity_to_insert integer;\n    v_spec_instructions_to_insert text;\n    v_student_balance numeric;\n    v_counter_id_for_item uuid; -- To store counter_id for insertion\nBEGIN\n    -- Input validation\n    IF p_student_user_id IS NULL THEN RAISE EXCEPTION 'Student user ID cannot be null'; END IF;\n    IF array_length(p_items, 1) IS NULL OR array_length(p_items, 1) = 0 THEN RAISE EXCEPTION 'Order must contain at least one item'; END IF;\n    IF p_pickup_time IS NULL THEN RAISE EXCEPTION 'Pickup time cannot be null'; END IF;\n    IF p_total_price <= 0 THEN RAISE EXCEPTION 'Total price must be positive'; END IF;\n\n    -- 1. Pre-check loop: Validate items (availability, stock)\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        IF v_input_item.quantity <= 0 THEN RAISE EXCEPTION 'Item quantity must be positive for menu item %', v_input_item.menu_item_id; END IF;\n\n        SELECT id, stock, available, counter_id\n        INTO v_menu_item\n        FROM public.menu_items\n        WHERE id = v_input_item.menu_item_id;\n\n        IF NOT FOUND THEN RAISE EXCEPTION 'Menu item % not found', v_input_item.menu_item_id; END IF;\n        IF NOT v_menu_item.available THEN RAISE EXCEPTION 'Menu item % is not available', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.stock IS NOT NULL AND v_menu_item.stock < v_input_item.quantity THEN\n            RAISE EXCEPTION 'Insufficient stock for menu item % (available: %, requested: %)', v_input_item.menu_item_id, v_menu_item.stock, v_input_item.quantity;\n        END IF;\n    END LOOP;\n\n    -- 2. Check student balance AND DEDUCT\n    SELECT balance INTO v_student_balance FROM public.profiles WHERE id = p_student_user_id FOR UPDATE; -- Lock the row\n    IF NOT FOUND THEN RAISE EXCEPTION 'Student profile not found for ID %', p_student_user_id; END IF;\n    IF v_student_balance IS NULL OR v_student_balance < p_total_price THEN\n        RAISE EXCEPTION 'Insufficient student balance (Available: %, Required: %)', COALESCE(v_student_balance, 0), p_total_price;\n    END IF;\n    UPDATE public.profiles SET balance = balance - p_total_price WHERE id = p_student_user_id;\n\n    -- 3. Insert the main order record\n    INSERT INTO public.orders (user_id, total_price, status, pickup_time, subtotal, tax, payment_method)\n    VALUES (\n        p_student_user_id,\n        p_total_price,\n        'pending'::public.order_status, -- Student orders start as pending\n        p_pickup_time,\n        p_subtotal,\n        p_tax,\n        'online'::public.payment_method_type -- Student orders are online\n    )\n    RETURNING id INTO v_order_id;\n\n    -- 4. Main loop: Insert order items and DECREMENT stock\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        -- Fetch price and counter_id again inside transaction for consistency\n        SELECT price, counter_id\n        INTO v_price_at_order, v_counter_id_for_item\n        FROM public.menu_items\n        WHERE id = v_input_item.menu_item_id;\n\n        v_item_id_to_insert := v_input_item.menu_item_id;\n        v_quantity_to_insert := v_input_item.quantity;\n        v_spec_instructions_to_insert := v_input_item.special_instructions;\n\n        INSERT INTO public.order_items (order_id, menu_item_id, quantity, price_at_order, counter_id, special_instructions, status)\n        VALUES (v_order_id, v_item_id_to_insert, v_quantity_to_insert, v_price_at_order, v_counter_id_for_item, v_spec_instructions_to_insert, 'pending'::public.order_item_status); -- Items start pending\n\n        -- Decrement stock directly using UPDATE\n        UPDATE public.menu_items\n        SET stock = stock - v_quantity_to_insert\n        WHERE id = v_item_id_to_insert AND stock IS NOT NULL;\n    END LOOP;\n\n    -- 5. Return the new order ID\n    RETURN v_order_id;\n\nEXCEPTION WHEN OTHERS THEN\n    RAISE WARNING 'Error in create_student_order for user %: %', p_student_user_id, SQLERRM;\n    RAISE; -- Re-raise to ensure transaction rollback\nEND;\n$function$\n"
  },
  {
    "routine_name": "register_and_pay_event",
    "routine_type": "FUNCTION",
    "data_type": "event_registrations",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.register_and_pay_event(p_event_id uuid)\n RETURNS event_registrations\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_student_id uuid := auth.uid(); -- Get the ID of the currently authenticated user\n  v_event record;\n  v_student_profile record;\n  v_existing_registration public.event_registrations;\n  v_registration_count integer;\n  v_new_registration public.event_registrations;\nBEGIN\n  -- 1. Input Validation\n  IF v_student_id IS NULL THEN\n    RAISE EXCEPTION 'AUTH_REQUIRED: User must be logged in to register.';\n  END IF;\n  IF p_event_id IS NULL THEN\n    RAISE EXCEPTION 'INVALID_INPUT: Event ID cannot be null.';\n  END IF;\n\n  -- 2. Fetch Event Details (Lock the row for consistency if needed, though less critical here)\n  SELECT * INTO v_event FROM public.events WHERE id = p_event_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'NOT_FOUND: Event % not found.', p_event_id;\n  END IF;\n\n  -- 3. Fetch Student Profile and Balance (Lock the row for update)\n  SELECT * INTO v_student_profile FROM public.profiles WHERE id = v_student_id FOR UPDATE;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'NOT_FOUND: Student profile % not found.', v_student_id;\n  END IF;\n\n  -- 4. Check if Event is Paid\n  IF NOT v_event.is_paid OR v_event.payment_amount IS NULL OR v_event.payment_amount <= 0 THEN\n    RAISE EXCEPTION 'INVALID_OPERATION: Event % is not a paid event or amount is invalid.', p_event_id;\n  END IF;\n\n  -- 5. Check Student Balance\n  IF v_student_profile.balance < v_event.payment_amount THEN\n    RAISE EXCEPTION 'INSUFFICIENT_FUNDS: Insufficient balance. Required: %, Available: %', v_event.payment_amount, v_student_profile.balance;\n  END IF;\n\n  -- 6. Check Registration Deadline\n  IF v_event.registration_deadline IS NOT NULL AND v_event.registration_deadline < now() THEN\n    RAISE EXCEPTION 'REGISTRATION_CLOSED: Registration deadline has passed.';\n  END IF;\n\n  -- 7. Check Existing Registration (Lock the potential row)\n  SELECT * INTO v_existing_registration\n  FROM public.event_registrations\n  WHERE event_id = p_event_id AND student_id = v_student_id\n  FOR UPDATE; -- Lock if exists\n\n  IF v_existing_registration IS NOT NULL AND v_existing_registration.status <> 'cancelled' THEN\n    RAISE EXCEPTION 'ALREADY_REGISTERED: Already registered for this event with status %.', v_existing_registration.status;\n  END IF;\n\n  -- 8. Check Seat Availability (Count active registrations)\n  SELECT count(*) INTO v_registration_count\n  FROM public.event_registrations\n  WHERE event_id = p_event_id AND status IN ('reserved', 'paid');\n\n  IF v_event.total_seats > 0 AND v_registration_count >= v_event.total_seats THEN\n    RAISE EXCEPTION 'SEATS_FULL: No more seats available for this event.';\n  END IF;\n\n  -- 9. Deduct Balance from Student\n  UPDATE public.profiles\n  SET balance = balance - v_event.payment_amount\n  WHERE id = v_student_id;\n\n  -- 10. Insert or Update Registration\n  IF v_existing_registration IS NOT NULL AND v_existing_registration.status = 'cancelled' THEN\n    -- Update the cancelled registration to 'paid'\n    UPDATE public.event_registrations\n    SET\n      status = 'paid',\n      paid_at = now(),\n      registration_time = now(), -- Reset registration time? Optional.\n      expires_at = NULL, -- Clear expiration for paid status\n      updated_at = now()\n    WHERE id = v_existing_registration.id\n    RETURNING * INTO v_new_registration;\n  ELSE\n    -- Insert new registration\n    INSERT INTO public.event_registrations (event_id, student_id, status, paid_at, payment_intent_id)\n    VALUES (p_event_id, v_student_id, 'paid', now(), NULL) -- Set status directly to 'paid'\n    RETURNING * INTO v_new_registration;\n  END IF;\n\n  -- 11. Credit the club's balance (Uncommented)\n  UPDATE public.profiles \n  SET balance = COALESCE(balance, 0) + v_event.payment_amount \n  WHERE id = v_event.club_id; -- Ensure club_id exists in v_event\n\n  -- 12. Return the new/updated registration record\n  RETURN v_new_registration;\n\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log the error details\n    RAISE WARNING 'Error in register_and_pay_event for event %, student %: %', p_event_id, v_student_id, SQLERRM;\n    -- Re-raise the original exception to ensure transaction rollback and inform the client\n    RAISE;\nEND;\n$function$\n"
  },
  {
    "routine_name": "reject_vendor_application",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.reject_vendor_application(p_application_id uuid, p_user_id uuid, p_reviewer_notes text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  is_caller_admin boolean;\nBEGIN\n  -- 1. Verify the caller is an admin\n  SELECT public.is_admin() INTO is_caller_admin;\n  IF NOT is_caller_admin THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not an admin.';\n  END IF;\n\n  -- 2. Update vendor_applications table\n  UPDATE public.vendor_applications\n  SET\n    status = 'rejected',\n    reviewer_notes = p_reviewer_notes,\n    reviewed_at = now()\n  WHERE id = p_application_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Vendor application with ID % not found.', p_application_id;\n  END IF;\n\n  -- 3. Update profiles table status to 'rejected'\n  UPDATE public.profiles\n  SET\n    status = 'rejected' -- Set profile status to rejected\n  WHERE id = p_user_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Profile with user ID % not found.', p_user_id;\n  END IF;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "update_order_status_based_on_items",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.update_order_status_based_on_items(p_order_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  item_statuses order_item_status[]; -- Use the correct enum type if defined, otherwise text[]\n  total_items integer;\n  pending_count integer;\n  preparing_count integer; -- Added count for preparing\n  ready_count integer;\n  delivered_count integer;\n  new_order_status order_status; -- Use the correct enum type\n  current_order_status order_status; -- To check current status for pending->confirmed logic\nBEGIN\n  -- 1. Get all item statuses for the given order\n  SELECT array_agg(status), count(*)\n  INTO item_statuses, total_items\n  FROM public.order_items\n  WHERE order_id = p_order_id;\n\n  -- Handle case where order has no items (shouldn't happen in normal flow)\n  IF total_items IS NULL OR total_items = 0 THEN\n    RAISE WARNING 'Order % has no items, cannot determine status.', p_order_id;\n    -- Optionally set status to 'cancelled' or leave as is\n    -- UPDATE public.orders SET status = 'cancelled' WHERE id = p_order_id;\n    RETURN;\n  END IF;\n\n  -- 2. Count items in each status category, including 'preparing'\n  SELECT\n    count(*) FILTER (WHERE status = 'pending'),\n    count(*) FILTER (WHERE status = 'preparing'), -- Count preparing items\n    count(*) FILTER (WHERE status = 'ready'),\n    count(*) FILTER (WHERE status = 'delivered')\n  INTO pending_count, preparing_count, ready_count, delivered_count\n  FROM public.order_items\n  WHERE order_id = p_order_id;\n\n  -- 3. Determine the new overall order status based on item counts (Revised Logic)\n  IF delivered_count = total_items THEN\n    new_order_status := 'completed';\n    -- Stock is now decremented at order creation time.\n  ELSIF delivered_count > 0 THEN\n    new_order_status := 'partially_delivered'; -- If any are delivered, it's partially delivered (highest precedence after completed)\n  ELSIF ready_count = total_items THEN\n     new_order_status := 'ready'; -- If all remaining are ready\n  ELSIF preparing_count > 0 THEN\n     new_order_status := 'preparing'; -- If any are preparing (and none delivered), the order is preparing\n  ELSIF ready_count > 0 THEN\n    new_order_status := 'partially_ready'; -- If some are ready, others pending (none preparing or delivered)\n  ELSIF pending_count = total_items THEN\n     -- If all items are pending, check the current order status.\n     -- If it was 'confirmed', keep it as 'confirmed'. Otherwise, set to 'pending'.\n     -- This prevents reverting from 'confirmed' back to 'pending' just because items haven't started preparation.\n     SELECT status INTO current_order_status FROM public.orders WHERE id = p_order_id;\n     IF current_order_status = 'confirmed' THEN\n        new_order_status := 'confirmed';\n     ELSE\n        new_order_status := 'pending'; -- Default for new orders or if somehow reverted\n     END IF;\n  ELSE\n     -- Fallback case: Should ideally not be reached with the logic above.\n     -- If it is reached, it implies a mix not covered (e.g., only pending and preparing?). Default to preparing if any exist.\n     IF preparing_count > 0 THEN\n         new_order_status := 'preparing';\n     ELSIF ready_count > 0 THEN\n         new_order_status := 'partially_ready';\n     ELSE\n         new_order_status := 'pending';\n     END IF;\n     RAISE WARNING 'Order % hit fallback status logic. Counts: Pending=%, Preparing=%, Ready=%, Delivered=%, Total=%. Setting status to %',\n         p_order_id, pending_count, preparing_count, ready_count, delivered_count, total_items, new_order_status;\n  END IF;\n\n  -- 4. Update the order status only if it has changed\n  UPDATE public.orders\n  SET status = new_order_status, updated_at = now()\n  WHERE id = p_order_id AND status IS DISTINCT FROM new_order_status;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "update_menu_item_availability_on_stock_change",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.update_menu_item_availability_on_stock_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Check if stock is being updated and is not null\n  IF NEW.stock IS NOT NULL THEN\n    -- If stock is zero or less, set available to false\n    IF NEW.stock <= 0 THEN\n      NEW.available := false;\n    -- Optional: If stock is positive, set available to true\n    -- Consider if manual override of 'available = false' is needed.\n    -- For now, we'll re-enable if stock increases above 0.\n    ELSIF NEW.stock > 0 THEN\n       NEW.available := true;\n    END IF;\n  END IF;\n\n  -- Return the modified row\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "routine_name": "cancel_overdue_pickup_orders",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.cancel_overdue_pickup_orders()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  overdue_order_count integer;\nBEGIN\n  -- Update orders that are 'ready' and whose 'ready_at' timestamp is older than 30 minutes ago\n  WITH updated_orders AS (\n    UPDATE public.orders\n    SET status = 'cancelled',\n        updated_at = now() -- Update the timestamp\n    WHERE status = 'ready'\n      AND ready_at IS NOT NULL -- Ensure ready_at has been set\n      AND ready_at < (now() - interval '30 minutes')\n    RETURNING id -- Return the IDs of updated orders\n  )\n  -- Increment stock for the items in the cancelled orders\n  SELECT count(updated_orders.id) INTO overdue_order_count FROM updated_orders;\n\n  IF overdue_order_count > 0 THEN\n    DECLARE\n      item_record record;\n    BEGIN\n      FOR item_record IN\n        SELECT oi.menu_item_id, oi.quantity\n        FROM public.order_items oi\n        JOIN updated_orders uo ON oi.order_id = uo.id\n        -- No need to check item status here, as the order status was 'ready', implying items weren't 'delivered'\n      LOOP\n        PERFORM public.increment_menu_item_stock(item_record.menu_item_id, item_record.quantity);\n      END LOOP;\n    EXCEPTION\n      WHEN OTHERS THEN\n        RAISE WARNING 'Error incrementing stock during overdue order cancellation: %', SQLERRM;\n    END;\n\n    -- Log how many orders were cancelled\n    RAISE LOG 'Cancelled % overdue pickup orders.', overdue_order_count;\n  END IF;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "mark_item_delivered_and_update_order",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.mark_item_delivered_and_update_order(p_order_item_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_order_id uuid;\n  v_counter_id uuid;\n  v_vendor_id uuid := auth.uid(); -- Get the current user's ID\n  v_user_role public.user_role;\n  v_all_items_delivered boolean;\n  v_current_order_status public.order_status;\nBEGIN\n  -- Check if the current user has the 'vendor' role\n  SELECT role INTO v_user_role\n  FROM public.profiles\n  WHERE id = v_vendor_id;\n\n  IF v_user_role IS NULL OR v_user_role <> 'vendor'::public.user_role THEN\n    RAISE EXCEPTION 'Permission denied: User is not a vendor.'; -- Modified error message\n  END IF;\n\n  -- Get order_id and counter_id, and verify vendor ownership of the counter\n  -- The vendor ID check (c.vendor_id = v_vendor_id) now uses the confirmed vendor's auth.uid()\n  SELECT oi.order_id, oi.counter_id INTO v_order_id, v_counter_id\n  FROM public.order_items oi\n  JOIN public.counters c ON oi.counter_id = c.id\n  WHERE oi.id = p_order_item_id AND c.vendor_id = v_vendor_id;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Permission denied: Order item not found or does not belong to this vendor.';\n  END IF;\n\n  -- Update the specific order item status to 'delivered'\n  UPDATE public.order_items\n  SET status = 'delivered'\n  WHERE id = p_order_item_id;\n\n  -- Check the current status of the main order\n  SELECT status INTO v_current_order_status FROM public.orders WHERE id = v_order_id;\n\n  -- Only proceed if the order is not already completed or cancelled\n  IF v_current_order_status <> 'completed' AND v_current_order_status <> 'cancelled' THEN\n\n    -- Check if all items for this order are now delivered\n    SELECT NOT EXISTS (\n      SELECT 1\n      FROM public.order_items\n      WHERE order_id = v_order_id AND status <> 'delivered'\n    ) INTO v_all_items_delivered;\n\n    -- Update the main order status\n    IF v_all_items_delivered THEN\n      UPDATE public.orders\n      SET status = 'completed'\n      WHERE id = v_order_id;\n    ELSE\n      -- If at least one item is delivered (which we just did), set to partially_completed\n      UPDATE public.orders\n      SET status = 'partially_completed'\n      WHERE id = v_order_id;\n    END IF;\n\n  END IF;\n\nEND;\n$function$\n"
  },
  {
    "routine_name": "handle_user_email_update",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.handle_user_email_update()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  UPDATE public.profiles\n  SET email = NEW.email\n  WHERE id = NEW.id;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "routine_name": "trigger_set_timestamp",
    "routine_type": "FUNCTION",
    "data_type": "trigger",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "routine_name": "decrement_menu_item_stock",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.decrement_menu_item_stock(p_menu_item_id uuid, p_quantity integer)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check for positive quantity\n    IF p_quantity <= 0 THEN\n        RAISE WARNING 'Decrement quantity must be positive for menu item %.', p_menu_item_id;\n        RETURN; -- Do nothing if quantity is not positive\n    END IF;\n\n    -- Update stock only if stock tracking is enabled (stock is not null)\n    UPDATE public.menu_items\n    SET stock = stock - p_quantity\n    WHERE id = p_menu_item_id\n      AND stock IS NOT NULL; -- Only decrement if stock is tracked\n\n    -- Optional: Add a check after update to see if stock went negative,\n    -- although pre-checks in application logic should ideally prevent this.\n    -- Example:\n    -- IF FOUND AND (SELECT stock FROM public.menu_items WHERE id = p_menu_item_id) < 0 THEN\n    --     RAISE WARNING 'Stock for menu item % went negative after decrement.', p_menu_item_id;\n    --     -- Consider corrective action or more robust error handling if needed\n    -- END IF;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Log any unexpected errors during the stock update\n        RAISE WARNING 'Error in decrement_menu_item_stock for item %: %', p_menu_item_id, SQLERRM;\n        -- Re-raise the exception if you want the calling transaction to fail\n        -- RAISE;\nEND;\n$function$\n"
  },
  {
    "routine_name": "create_pos_order",
    "routine_type": "FUNCTION",
    "data_type": "uuid",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.create_pos_order(p_vendor_user_id uuid, p_counter_id uuid, p_items pos_order_item_input[], p_payment_method payment_method_type, p_student_user_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_order_id uuid;\n    v_total_price numeric := 0;\n    v_input_item public.pos_order_item_input;\n    v_menu_item record;\n    v_price_at_order numeric;\n    v_item_id_to_insert uuid;\n    v_quantity_to_insert integer;\n    v_spec_instructions_to_insert text;\n    v_student_balance numeric;\n    v_user_id_for_insert uuid; -- Renamed variable for clarity\nBEGIN\n    -- Input validation\n    IF p_vendor_user_id IS NULL THEN RAISE EXCEPTION 'Vendor user ID cannot be null'; END IF;\n    IF p_counter_id IS NULL THEN RAISE EXCEPTION 'Counter ID cannot be null'; END IF;\n    IF p_payment_method IS NULL THEN RAISE EXCEPTION 'Payment method cannot be null'; END IF;\n    IF array_length(p_items, 1) IS NULL OR array_length(p_items, 1) = 0 THEN RAISE EXCEPTION 'Order must contain at least one item'; END IF;\n    IF p_payment_method = 'online' AND p_student_user_id IS NULL THEN RAISE EXCEPTION 'Student user ID is required for online payments.'; END IF;\n\n    -- 1. Pre-check loop: Validate items and calculate total price\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        IF v_input_item.quantity <= 0 THEN RAISE EXCEPTION 'Item quantity must be positive for menu item %', v_input_item.menu_item_id; END IF;\n        SELECT id, price, stock, available, counter_id INTO v_menu_item FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        IF NOT FOUND THEN RAISE EXCEPTION 'Menu item % not found', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.counter_id != p_counter_id THEN RAISE EXCEPTION 'Menu item % does not belong to counter %', v_input_item.menu_item_id, p_counter_id; END IF;\n        IF NOT v_menu_item.available THEN RAISE EXCEPTION 'Menu item % is not available', v_input_item.menu_item_id; END IF;\n        IF v_menu_item.stock IS NOT NULL AND v_menu_item.stock < v_input_item.quantity THEN\n            RAISE EXCEPTION 'Insufficient stock for menu item % (available: %, requested: %)', v_input_item.menu_item_id, v_menu_item.stock, v_input_item.quantity;\n        END IF;\n        v_total_price := v_total_price + (v_menu_item.price * v_input_item.quantity);\n    END LOOP;\n\n    -- 2. Check student balance AND DEDUCT if payment is online\n    IF p_payment_method = 'online' THEN\n        SELECT balance INTO v_student_balance FROM public.profiles WHERE id = p_student_user_id FOR UPDATE;\n        IF NOT FOUND THEN RAISE EXCEPTION 'Student profile not found for ID %', p_student_user_id; END IF;\n        IF v_student_balance IS NULL OR v_student_balance < v_total_price THEN\n            RAISE EXCEPTION 'Insufficient student balance (Available: %, Required: %)', COALESCE(v_student_balance, 0), v_total_price;\n        END IF;\n        UPDATE public.profiles SET balance = balance - v_total_price WHERE id = p_student_user_id;\n        -- Explicitly set the user ID for insert AFTER balance check\n        v_user_id_for_insert := p_student_user_id;\n    ELSE\n        -- Explicitly set the user ID for insert for cash orders\n        v_user_id_for_insert := p_vendor_user_id;\n    END IF;\n\n    -- 3. Insert the main order record\n    INSERT INTO public.orders (user_id, total_price, status, pickup_time, subtotal, tax, payment_method)\n    VALUES (\n        v_user_id_for_insert, -- Use the explicitly assigned variable\n        v_total_price,\n        'completed'::public.order_status,\n        now(),\n        v_total_price,\n        0,\n        p_payment_method\n    )\n    RETURNING id INTO v_order_id;\n\n    -- 4. Main loop: Insert order items and update stock\n    FOREACH v_input_item IN ARRAY p_items LOOP\n        SELECT price INTO v_price_at_order FROM public.menu_items WHERE id = v_input_item.menu_item_id;\n        v_item_id_to_insert := v_input_item.menu_item_id;\n        v_quantity_to_insert := v_input_item.quantity;\n        v_spec_instructions_to_insert := v_input_item.special_instructions;\n        INSERT INTO public.order_items (order_id, menu_item_id, quantity, price_at_order, counter_id, special_instructions, status)\n        VALUES (v_order_id, v_item_id_to_insert, v_quantity_to_insert, v_price_at_order, p_counter_id, v_spec_instructions_to_insert, 'delivered'::public.order_item_status);\n        UPDATE public.menu_items SET stock = stock - v_quantity_to_insert WHERE id = v_item_id_to_insert AND stock IS NOT NULL;\n    END LOOP;\n\n    -- 5. Update Vendor Balance (Original Step Numbering)\n    UPDATE public.profiles\n    SET balance = COALESCE(balance, 0) + v_total_price\n    WHERE id = p_vendor_user_id;\n\n    -- 6. Return the new order ID (Original Step Numbering)\n    RETURN v_order_id;\n\nEXCEPTION WHEN OTHERS THEN\n    RAISE WARNING 'Error in create_pos_order: %', SQLERRM;\n    RAISE; -- Re-raise to ensure transaction rollback\nEND;\n$function$\n"
  },
  {
    "routine_name": "approve_vendor_application",
    "routine_type": "FUNCTION",
    "data_type": "void",
    "external_language": "plpgsql",
    "routine_definition": "CREATE OR REPLACE FUNCTION public.approve_vendor_application(p_application_id uuid, p_user_id uuid, p_reviewer_notes text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  is_caller_admin boolean;\n  v_business_type text;\n  v_target_role public.user_role; -- Variable for the role to assign\nBEGIN\n  -- 1. Verify the caller is an admin\n  SELECT public.is_admin() INTO is_caller_admin;\n  IF NOT is_caller_admin THEN\n    RAISE EXCEPTION 'Permission denied: Caller is not an admin.';\n  END IF;\n\n  -- Get the business type from the application\n  SELECT business_type INTO v_business_type\n  FROM public.vendor_applications\n  WHERE id = p_application_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Vendor application with ID % not found.', p_application_id;\n      RETURN; -- Exit if application not found\n  END IF;\n\n  -- Determine the target role based on business type value (e.g., 'club')\n  -- Compare against the actual value saved from the form ('club'), not the label ('Student Club')\n  IF lower(trim(v_business_type)) = 'club' AND EXISTS (SELECT 1 FROM pg_enum WHERE enumtypid = 'user_role'::regtype AND enumlabel = 'club') THEN\n      v_target_role := 'club'::public.user_role;\n  ELSE\n      v_target_role := 'vendor'::public.user_role; -- Default to vendor if business_type is not 'club'\n  END IF;\n\n  -- 2. Update vendor_applications table\n  UPDATE public.vendor_applications\n  SET\n    status = 'approved',\n    reviewer_notes = p_reviewer_notes,\n    reviewed_at = now()\n  WHERE id = p_application_id;\n\n  -- 3. Update profiles table with the determined role\n  UPDATE public.profiles\n  SET\n    role = v_target_role, -- Use the determined role\n    status = 'active'\n  WHERE id = p_user_id;\n\n  IF NOT FOUND THEN\n      RAISE WARNING 'Profile with user ID % not found during approval.', p_user_id;\n  END IF;\n\nEND;\n$function$\n"
  }
]